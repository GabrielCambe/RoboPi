from time import sleep
from gpiozero import Motor  # this library uses BCM numbering for the Pi's pins

#from math import calculate_steering_discount, round_to_1_if_greater
import mathematics

# .
def update_trim_factors(pwmRight, pwmLeft, ticksRight, ticksLeft, trimFactorRight, trimFactorLeft):
    # Calculating trim factor using the encoder information
    if(pwmRight.value == pwmLeft.value):
        if(ticksRight.value > ticksLeft.value):
            trimFactorRight.value = mathematics.round_to_1_if_greater(trimFactorRight.value + (pwmRight.value/320)) #0.001953125    
            
        elif(ticksRight.value < ticksLeft.value):
            trimFactorLeft.value = mathematics.round_to_1_if_greater(trimFactorLeft.value + (pwmLeft.value/320))
            
    elif(pwmRight.value > pwmLeft.value and ticksRight.value < ticksLeft.value):
        trimFactorLeft.value = mathematics.round_to_1_if_greater(trimFactorLeft.value + (pwmLeft.value/320))
        
    elif(pwmRight.value < pwmLeft.value and ticksRight.value > ticksLeft.value):
        trimFactorRight.value = mathematics.round_to_1_if_greater(trimFactorRight.value + (pwmRight.value/320))

        
# This function sets the PWM values of each separate motor, using the control point generated by the gamepad  and the map_to_unit_intervalfunction
def thread_reset_factors(trimFactorRight, trimFactorLeft):
    while True:
        trimFactorRight.value = 0
        trimFactorLeft.value = 0
        sleep(0.5)



# This function is called whenever the optic sensors detect a change in one of the wheels
def ticks_pin_changed(ticks):
    print(ticks.value)
    ticks.value = ticks.value + 1

                
# ..                
def thread_reset_ticks(ticksRight, ticksLeft):
    while True:                
        ticksRight.value = 0    
        ticksLeft.value = 0
        sleep(8)
    

        
# This function sets the PWM values of each separate motor, using the control point generated by the gamepad  and the map_to_unit_intervalfunction
def set_pwm_value(Lx, Ly, pwmPoint, pwm, pwmLeft, pwmRight, trimFactorRight, trimFactorLeft, ticksRight, ticksLeft):
    if(Lx.value < 128):
        pwmLeft.value = abs(pwm.value - mathematics.calculate_steering_discount(pwmPoint))
        pwmRight.value = abs(pwm.value)

    elif(Lx.value > 128):
        pwmLeft.value = abs(pwm.value)
        pwmRight.value = abs(pwm.value - mathematics.calculate_steering_discount(pwmPoint))
        
    elif(Lx.value == 128):
        if(Ly.value != 128):
            pwmLeft.value = abs(pwm.value)
            pwmRight.value = abs(pwm.value)
        else:
            pwmLeft.value = 0
            pwmRight.value = 0
    
    trimFactorRight.value = 0
    trimFactorLeft.value = 0
    
    ticksRight.value = 0
    ticksLeft.value = 0


    
# ...
def thread_motors_controller(ticksRight, ticksLeft, trimFactorRight, trimFactorLeft, pwmRight, pwmLeft, Lx, Ly):
    # Instantiate motors
    leftMotor = Motor(6, 5)
    rightMotor = Motor(26, 13)

    # Main loop
    while True:
        update_trim_factors(pwmRight, pwmLeft, ticksRight, ticksLeft, trimFactorRight, trimFactorLeft)
        
        # Updating pwm 
        if(Ly.value < 128):
            leftMotor.stop()
            rightMotor.stop()
                
            leftMotor.forward(abs(pwmLeft.value * (1 - trimFactorLeft.value)))
            rightMotor.forward(abs(pwmRight.value * (1 - trimFactorRight.value)))

        elif(Ly.value > 128):
            leftMotor.stop()
            rightMotor.stop()
                
            leftMotor.backward(abs(pwmLeft.value * (1 - trimFactorLeft.value)))
            rightMotor.backward(abs(pwmRight.value * (1 - trimFactorRight.value)))

        elif(Ly.value == 128):
            if(Lx.value < 128):
                leftMotor.stop()
                rightMotor.stop()
                
                leftMotor.backward(abs(pwmLeft.value * (1 - trimFactorLeft.value)))
                rightMotor.forward(abs(pwmRight.value * (1 - trimFactorRight.value)))

            elif(Lx.value > 128):
                leftMotor.stop()
                rightMotor.stop()
                
                leftMotor.forward(abs(pwmLeft.value * (1 - trimFactorLeft.value)))
                rightMotor.backward(abs(pwmRight.value * (1 - trimFactorRight.value)))

            elif(Lx.value == 128):
                leftMotor.stop()
                rightMotor.stop()

        #ticksRight.value = 0    
        #ticksLeft.value = 0
        
        sleep(0.003125)
