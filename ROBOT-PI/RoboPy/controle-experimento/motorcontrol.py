import numpy as np
from time import sleep
from gpiozero import Motor  # this library uses BCM numbering for the Pi's pins

import mathematics #from math import calculate_steering_discount, round_to_1_if_greater
import regressor #from regressor import loadRegressor
import filters

# .o
def update_trim_factors(
    var,
    frequency
):        
    if(var['UsingPwmRegressor'].value):
        # Calculating trim factor using the encoder information
        resolution = (frequency/3.0)
    else:
        resolution = frequency/2.0
    
    ticksDiff = abs(float(var['ticksRight'].value - var['ticksLeft'].value))
    pwmDiff = var['pwmRight'].value - var['pwmLeft'].value

    if(pwmDiff == 0):
        if((ticksDiff) > 0):
            var['trimFactorRight'].value = mathematics.round_to_1_if_greater(var['trimFactorRight'].value + (var['pwmRight'].value/resolution))    
            var['trimFactorLeft'].value = mathematics.round_to_0_if_smaller(var['trimFactorLeft'].value - (var['pwmLeft'].value/2*resolution))
            
        elif((ticksDiff) < 0):
            var['trimFactorRight'].value = mathematics.round_to_0_if_smaller(var['trimFactorRight'].value - (var['pwmRight'].value/2*resolution))
            var['trimFactorLeft'].value = mathematics.round_to_1_if_greater(var['trimFactorLeft'].value + (var['pwmLeft'].value/resolution))
            
    elif(pwmDiff > 0):
        if(ticksDiff <= 0):
            var['trimFactorRight'].value = mathematics.round_to_0_if_smaller(var['trimFactorRight'].value - (var['pwmRight'].value/2*resolution))
            var['trimFactorLeft'].value = mathematics.round_to_1_if_greater(var['trimFactorLeft'].value + (var['pwmLeft'].value/resolution))
        
        elif(ticksDiff > 0):
            var['trimFactorRight'].value = mathematics.round_to_0_if_smaller(var['trimFactorRight'].value - (var['pwmRight'].value/2*resolution))
            var['trimFactorLeft'].value = mathematics.round_to_0_if_smaller(var['trimFactorLeft'].value - (var['pwmLeft'].value/resolution))

    elif(pwmDiff < 0):
        if(ticksDiff >= 0):
            var['trimFactorRight'].value = mathematics.round_to_1_if_greater(var['trimFactorRight'].value + (var['pwmRight'].value/resolution))    
            var['trimFactorLeft'].value = mathematics.round_to_0_if_smaller(var['trimFactorLeft'].value - (var['pwmLeft'].value/2*resolution))

        elif(ticksDiff < 0):
            var['trimFactorRight'].value = mathematics.round_to_0_if_smaller(var['trimFactorRight'].value - (var['pwmRight'].value/2*resolution))
            var['trimFactorLeft'].value = mathematics.round_to_0_if_smaller(var['trimFactorLeft'].value - (var['pwmLeft'].value/resolution))

    if var['UsingLogic'].value:
        var['trimFactorRight'].value = 0.0    
        var['trimFactorLeft'].value = 0.0


# This function sets the PWM values of each separate motor, using the control point generated by the gamepad  and the map_to_unit_intervalfunction
def reset_factors(frequency, trimFactorRight, trimFactorLeft, loop):
    if(loop):
        while True:
            trimFactorRight.value = 0
            sleep((1.0/frequency))
            
    else:
        trimFactorRight.value = 0
        trimFactorLeft.value = 0
            

# This function is called whenever the optic sensors detect a change in one of the wheels
def encoder_pin_callback(callback_tuple):
    var, left = callback_tuple
    if left:
        if( var['ticksLeftDirection'].value > 0 ):
            var['ticksLeft'].value = var['ticksLeft'].value + 1
        else:
            var['ticksLeft'].value = var['ticksLeft'].value - 1
        
        print(var['ticksLeft'].value)
    else:
        if( var['ticksRightDirection'].value > 0 ):
            var['ticksRight'].value = var['ticksRight'].value + 1
        else:
            var['ticksRight'].value = var['ticksRight'].value - 1
        
        print(var['ticksRight'].value)
# ..                
def reset_ticks(frequency, ticksRight, ticksLeft, loop):
    if(loop):
        while True:                
            ticksRight.value = 0    
            ticksLeft.value = 0
            sleep((1.0/frequency))
    else:
        ticksRight.value = 0    
        ticksLeft.value = 0
        
        
# This function sets the PWM values of each separate motor, using the control point generated by the gamepad  and the map_to_unit_intervalfunction
def set_pwm_value(
    var,
    pwmLeftA, pwmLeftB, pwmRightA, pwmRightB
):
    if(var['Lx'].value < 128):
        if(var['Ly'].value != 128):
                var['pwmLeft'].value = (pwmLeftB - pwmLeftA) * (abs(var['pwm'].value) - (abs(var['pwm'].value) * var['steerLeft'].value)) + pwmLeftA
                var['pwmRight'].value = (pwmRightB - pwmRightA) * abs(var['pwm'].value) + pwmRightA
        else:
            var['pwmLeft'].value = (pwmLeftB - pwmLeftA) * abs(var['pwm'].value) + pwmLeftA
            var['pwmRight'].value = (pwmRightB - pwmRightA) * abs(var['pwm'].value) + pwmRightA
            
    elif(var['Lx'].value > 128):
        if(var['Ly'].value != 128):
                var['pwmLeft'].value = (pwmLeftB - pwmLeftA) * abs(var['pwm'].value) + pwmLeftA
                var['pwmRight'].value = (pwmRightB - pwmRightA) * (abs(var['pwm'].value)
                                - (abs(var['pwm'].value) * var['steerRight'].value)) + pwmRightA
        else:
            var['pwmLeft'].value = (pwmLeftB - pwmLeftA) * abs(var['pwm'].value) + pwmLeftA
            var['pwmRight'].value = (pwmRightB - pwmRightA) * abs(var['pwm'].value) + pwmRightA
    
    elif(var['Lx'].value == 128):
        if(var['Ly'].value != 128):
            var['pwmLeft'].value = (pwmLeftB - pwmLeftA) * abs(var['pwm'].value) + pwmLeftA
            var['pwmRight'].value = (pwmRightB - pwmRightA) * abs(var['pwm'].value) + pwmRightA
        else:
            var['pwmLeft'].value = 0
            var['pwmRight'].value = 0                
                    
    
# ...
def motors_controller(
    frequency,
    var,
    pwmLeftA, pwmLeftB, pwmRightA, pwmRightB
):
    # Instantiate motors
    leftMotor = Motor(6, 5)
    rightMotor = Motor(26, 13)

    # Main loop
    while True:        
        set_pwm_value(
            var,
            pwmLeftA, pwmLeftB, pwmRightA, pwmRightB
        )
        update_trim_factors(
            var,
            frequency
        )
        
        # Updating pwm 
        if(var['Ly'].value < 128):
            leftMotor.forward(abs(var['pwmLeft'].value * (1.0 - (var['trimFactorLeft'].value * var['steerLeft'].value))))
            var['ticksLeftDirection'].value = 1
            rightMotor.forward(abs(var['pwmRight'].value * (1.0 - (var['trimFactorRight'].value * var['steerRight'].value))))
            var['ticksRightDirection'].value = 1

        elif(var['Ly'].value > 128):
            leftMotor.backward(abs(var['pwmLeft'].value * (1.0 - (var['trimFactorLeft'].value * var['steerLeft'].value))))
            var['ticksLeftDirection'].value = -1
            rightMotor.backward(abs(var['pwmRight'].value * (1.0 - (var['trimFactorRight'].value * var['steerRight'].value))))
            var['ticksRightDirection'].value = -1

        elif(var['Ly'].value == 128):
            if(var['Lx'].value < 128):
                leftMotor.backward(abs(var['pwmLeft'].value * (1.0 - (var['trimFactorLeft'].value * var['steerLeft'].value))))
                var['ticksLeftDirection'].value = -1
                rightMotor.forward(abs(var['pwmRight'].value * (1.0 - (var['trimFactorRight'].value * var['steerRight'].value))))
                var['ticksRightDirection'].value = 1

            elif(var['Lx'].value > 128):
                leftMotor.forward(abs(var['pwmLeft'].value * (1.0 - (var['trimFactorLeft'].value * var['steerLeft'].value))))
                var['ticksLeftDirection'].value = 1
                rightMotor.backward(abs(var['pwmRight'].value * (1.0 - (var['trimFactorRight'].value * var['steerRight'].value))))
                var['ticksRightDirection'].value = -1

            elif(var['Lx'].value == 128):
                leftMotor.stop()
                var['ticksLeftDirection'].value = 0
                rightMotor.stop()
                var['ticksRightDirection'].value = 0

        sleep((1.0/frequency)) 